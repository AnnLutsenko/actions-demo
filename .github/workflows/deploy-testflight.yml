name: üöÄ Deploy to TestFlight

on:
  workflow_dispatch: # Manual trigger (safe for testing)
  # later you can add:
  # push:
  #   branches: [ main, release/* ]

jobs:
  build-and-upload:
    runs-on: macos-26

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.3' # Specify the Ruby version you need
          bundler-cache: true # Install gems from the Gemfile and cache them

      - name: Install Dependencies
        run: |
          gem install jwt

      - name: üîë Generate App Store Connect JWT
        id: generate_jwt
        env:
          ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          KEY_ID: ${{ secrets.APP_STORE_CONNECT_KEY_ID }}
          PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}
        run: |
          token=$(ruby -rjwt -ropenssl -e "
            private_key_obj = OpenSSL::PKey::EC.new(ENV['PRIVATE_KEY'])
            token = JWT.encode(
              {
                iss: ENV['ISSUER_ID'],
                exp: Time.now.to_i + 20 * 60,
                aud: 'appstoreconnect-v1'
              },
              private_key_obj,
              'ES256',
              header_fields = { kid: ENV['KEY_ID'] }
            )
            puts token
          ")
          echo "TOKEN=$token" >> $GITHUB_ENV

      - name: üîê Generate RSA Private Key and CSR
        id: generate_csr
        run: |
          # Generate RSA private key (2048 bits)
          openssl genpkey -algorithm RSA -out rsa_private.key -pkeyopt rsa_keygen_bits:2048

          # Create a CSR (Certificate Signing Request)
          openssl req -new -key rsa_private.key -out csr.certSigningRequest -subj "/CN=GitHubActionsBot, O=SearisAS, C=NO"

          echo "‚úÖ RSA private key and CSR generated successfully."

          # Save CSR content to environment for next steps (API call)
          CSR_CONTENT=$(cat csr.certSigningRequest | base64 | tr -d '\n')
          echo "CSR_CONTENT=$CSR_CONTENT" >> $GITHUB_ENV

      - name: üìÑ Request and Save Distribution Certificate
        env:
          TOKEN: ${{ env.TOKEN }}
          CSR_CONTENT: ${{ env.CSR_CONTENT }}
        run: |
          echo "üì° Requesting certificate from App Store Connect..."
          response=$(curl -s -X POST "https://api.appstoreconnect.apple.com/v1/certificates" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "data": {
                "type": "certificates",
                "attributes": {
                  "certificateType": "DISTRIBUTION",
                  "csrContent": "'"$CSR_CONTENT"'"
                }
              }
            }')
                
          status=$(echo "$response" | jq -r '.errors[0].status // .data.id')
          if [[ "$status" == null ]]; then
            echo "‚ùå Failed to create distribution certificate"
            echo "$response"
            exit 1
          fi
                
          cert_id=$(echo "$response" | jq -r '.data.id')
          cert_serial=$(echo "$response" | jq -r '.data.attributes.serialNumber')
          cert_content=$(echo "$response" | jq -r '.data.attributes.certificateContent')
                
          echo "‚úÖ Certificate created:"
          echo "ID: $cert_id"
          echo "Serial: $cert_serial"
                
          # Save certificate content with proper PEM headers
          {
            echo "-----BEGIN CERTIFICATE-----"
            echo "$cert_content"
            echo "-----END CERTIFICATE-----"
          } > distribution.cer
                
          echo "Certificate saved to distribution.cer"
          echo "CERT_ID=$cert_id" >> $GITHUB_ENV

      - name: üîß Convert Certificate to .p12 format
        env:
          CERT_P12_PASSWORD: ${{ secrets.CERT_P12_PASSWORD }} # store securely in GitHub Secrets
        run: |
          # Combine private key + certificate into a password-protected P12 file
          openssl pkcs12 -export \
            -inkey rsa_private.key \
            -in distribution.cer \
            -out distribution.p12 \
            -password pass:$CERT_P12_PASSWORD
        
          echo "‚úÖ distribution.p12 created successfully."
      
      - name: üì¶ Upload .p12 as GitHub Actions artifact
        uses: actions/upload-artifact@v4
        with:
          name: distribution-certificate
          path: distribution.p12
      
      - name: üîë Import certificate to keychain
        env:
          KEYCHAIN_PASSWORD: temp_pass
          CERT_P12_PASSWORD: ${{ secrets.CERT_P12_PASSWORD }}
        run: |
          # Create a temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
        
          # Import the P12 file into the new keychain
          security import distribution.p12 \
            -k ~/Library/Keychains/build.keychain \
            -P "$CERT_P12_PASSWORD" \
            -T /usr/bin/codesign
        
          # Make this keychain the default for codesign and unlock it
          security list-keychains -s ~/Library/Keychains/build.keychain
          security default-keychain -s ~/Library/Keychains/build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" ~/Library/Keychains/build.keychain
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" ~/Library/Keychains/build.keychain
        
          echo "üîì Keychain imported and unlocked for code signing."

      - name: üßæ Create Distribution Provisioning Profile
        env:
          TOKEN: ${{ env.TOKEN }}
          CERTIFICATE_ID: ${{ env.CERT_ID }}        # From previous step
          BUNDLE_ID: ${{ secrets.APP_BUNDLE_ID }}   # Store your bundle ID as a secret
        run: |
          echo "Creating Distribution Provisioning Profile..."
        
          PROFILE_NAME="MyApp Distribution Profile"
        
          response=$(curl -s -X POST "https://api.appstoreconnect.apple.com/v1/profiles" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            -d @- <<EOF
            {
              "data": {
                "type": "profiles",
                "attributes": {
                  "name": "$PROFILE_NAME",
                  "profileType": "IOS_APP_STORE"
                },
                "relationships": {
                  "bundleId": {
                    "data": {
                      "type": "bundleIds",
                      "id": "$BUNDLE_ID"
                    }
                  },
                  "certificates": {
                    "data": [
                      {
                        "type": "certificates",
                        "id": "$CERTIFICATE_ID"
                      }
                    ]
                  }
                }
              }
            }
            EOF
            )

          # Extract Base64-encoded profile content
          profile_content=$(echo "$response" | jq -r '.data.attributes.profileContent')

          if [ "$profile_content" == "null" ] || [ -z "$profile_content" ]; then
            echo "‚ùå Failed to create provisioning profile."
            echo "$response"
            exit 1
          fi

          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          echo "$profile_content" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/MyApp_Distribution_Profile.mobileprovision

          echo "‚úÖ Provisioning profile saved successfully."

      - name: üèóÔ∏è Build and Archive App
        run: |
          xcodebuild clean archive \
            -project Action\ Demo.xcodeproj \
            -scheme Action\ Demo \
            -configuration Release \
            -derivedDataPath "ios/build/DerivedData" \
            -archivePath $PWD/build/Action\ Demo.xcarchive \
            -allowProvisioningUpdates \
            DEVELOPMENT_TEAM=${{ secrets.APPLE_TEAM_ID }} \
            CODE_SIGN_STYLE=Manual \
            PROVISIONING_PROFILE_SPECIFIER="MyApp Distribution Profile"